

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RegExp Validator Documentation regExp.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="style.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">RegExp Validator Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="RegExpValidator.html">RegExpValidator</a></li></ul><h3>Interfaces</h3><ul><li><a href="ValidationResult.html">ValidationResult</a></li><li><a href="ValidatorOptions.html">ValidatorOptions</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>regExp.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>export type ValidationLevel = 'simple' | 'medium' | 'complex';
export type CountryCode = 'US' | 'UK' | 'CA' | 'ANY';
export type CryptoType = 'BTC' | 'ETH';
export type ValidatorMode = 'verbose' | undefined;

/**
 * Interface representing the result of a validation operation
 * @interface ValidationResult | boolean
 */
export interface ValidationResult {
    /** Indicates whether the validation was successful */
    isValid: boolean;
    /** Optional message providing details about the validation result */
    message?: string;
    /** Optional array containing any regex matches found */
    matches?: RegExpMatchArray | null;
}

/**
 * Interface for configuring validator behavior
 * @interface ValidatorOptions
 */
export interface ValidatorOptions {
    /** Maximum time (in milliseconds) allowed for validation operations */
    timeout?: number;
    /** Whether string matching should be case-sensitive */
    caseSensitive?: boolean;
    /** Whether to enable multiline matching */
    multiline?: boolean;
    /** Whether to enable Unicode features */
    unicode?: boolean;
}

/**
 * A comprehensive regular expression validator for common string patterns
 * @class RegExpValidator
 */
class RegExpValidator {
    private readonly patterns: {
        [key: string]: RegExp;
    } = {
        email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
        date: /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}$/,
        ipv4: /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
        ipv6: /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/,
        macAddress: /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/,
        url: /^(https?:\/\/)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(\/\S*)?$/,
        username: /^[a-zA-Z0-9._-]{3,16}$/,
        hexColor: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
        onlyIntegers: /^-?\d+$/,
        onlyAlpha: /^[a-zA-Z]+$/,
        emoji: /^[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{2300}-\u{23FF}\u{2B50}\u{203C}\u{2049}\u{2122}\u{2139}]+$/u,
        ansiArt: /^[\x20-\x7E\x0A\x0D]+$/,
        jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
        domain: /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
        semver: /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,
        phone: /^(\+\d{1,3}[- ]?)?\d{10}$/,
        creditCard:
            /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|6(?:011|5[0-9]{2})[0-9]{12})$/,
        ssn: /^(?!000|666|9\d{2})\d{3}-(?!00)\d{2}-(?!0000)\d{4}$/,
        isbn: /^(?:\d[- ]?){9}[\dXx]$|^(?:\d[- ]?){13}$/,
        time: /^(?:[01]\d|2[0-3]):[0-5]\d(:[0-5]\d)?( ?(?:AM|PM))?$/i,
    };

    private readonly complexPatterns = {
        postalCode: {
            US: /^\d{5}(-\d{4})?$/,
            UK: /^[A-Z]{1,2}\d[A-Z\d]? ?\d[A-Z]{2}$/i,
            CA: /^[ABCEGHJ-NPRSTVXY]\d[ABCEGHJ-NPRSTV-Z] ?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
            ANY: /^[A-Z0-9]{3,10}$/i,
        },
        crypto: {
            BTC: /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/,
            ETH: /^0x[a-fA-F0-9]{40}$/,
        },
        password: {
            simple: /^.{6,}$/,
            medium: /^.{8,}$/,
            complex:
                /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;!@#%^&amp;*()_+\-=~`{}[\]:;"'&lt;>,.?\/]{8,}$/,
        },
        coordinates: {
            latitude: /^-?([1-8]?\d(?:\.\d+)?|90(?:\.0+)?)$/,
            longitude: /^-?((1[0-7]|[1-9])?\d(?:\.\d+)?|180(?:\.0+)?)$/,
        },
    };

    constructor(private options: ValidatorOptions = {}) {
        this.options = {
            timeout: 5000,
            caseSensitive: true,
            multiline: false,
            unicode: true,
            ...options,
        };
    }

    /**
     * Internal validation method used by all other validation functions
     * @private
     * @param {string} value - The string to validate
     * @param {RegExp} pattern - The regular expression to test against
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result or boolean
     */
    private validate(
        value: string,
        pattern: RegExp,
        mode?: ValidatorMode,
    ): boolean | ValidationResult {
        const startTime = Date.now();
        try {
            if (Date.now() - startTime > (this.options.timeout || 5000)) {
                return mode === 'verbose'
                    ? {
                          isValid: false,
                          message: 'Validation timeout exceeded',
                      }
                    : false;
            }

            const isValid = pattern.test(value);

            if (mode === 'verbose') {
                return {
                    isValid,
                    matches: value.match(pattern),
                    message: isValid
                        ? 'Validation successful'
                        : 'Validation failed',
                };
            }

            return isValid;
        } catch (error) {
            return mode === 'verbose'
                ? {
                      isValid: false,
                      message: `Validation error: ${error}`,
                  }
                : false;
        }
    }

    /**
     * Validates an email address
     * @param {string} email - The email address to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkEmail(
        email: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(email, this.patterns.email, mode);
    }

    /**
     * Validates an IPv4 address
     * @param {string} ip - The IPv4 address to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkIPv4(
        ip: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(ip, this.patterns.ipv4, mode);
    }

    /**
     * Validates an IPv6 address
     * @param {string} ip - The IPv6 address to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkIPv6(
        ip: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(ip, this.patterns.ipv6, mode);
    }

    /**
     * Validates a MAC address
     * @param {string} mac - The MAC address to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkMacAddress(
        mac: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(mac, this.patterns.macAddress, mode);
    }

    /**
     * Validates a URL
     * @param {string} url - The URL to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkUrl(
        url: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(url, this.patterns.url, mode);
    }

    /**
     * Validates a username
     * @param {string} name - The username to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkUsername(
        name: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(name, this.patterns.username, mode);
    }

    /**
     * Validates a hexadecimal color code
     * @param {string} color - The color code to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkHexColor(
        color: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(color, this.patterns.hexColor, mode);
    }

    /**
     * Validates if a string contains only integers
     * @param {string} value - The string to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkOnlyIntegers(
        value: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(value, this.patterns.onlyIntegers, mode);
    }

    /**
     * Validates if a string contains only alphabetic characters
     * @param {string} value - The string to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkOnlyAlpha(
        value: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(value, this.patterns.onlyAlpha, mode);
    }

    /**
     * Validates if a string contains valid emoji characters
     * @param {string} value - The string to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkEmoji(
        value: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(value, this.patterns.emoji, mode);
    }

    /**
     * Validates if the given string matches the ANSI art format, which includes printable ASCII characters,
     * spaces, newline (`\n`), and carriage return (`\r`).
     * 
     * ansiArt: /^[\x20-\x7E\x0A\x0D]+$/,
     *
     * @param {string} value - The value to validate.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean}
     *   - Returns `true` or `false` if no mode is provided.
     *   - Returns an object with `isValid`, `matches`, and `message` when in 'verbose' mode.
     *

     *
     */
    public checkAnsiArt(
        value: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(value, this.patterns.ansiArt, mode);
    }

    /**
     * Validates a JWT token
     * @param {string} jwt - The JWT token to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkJwt(
        jwt: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(jwt, this.patterns.jwt, mode);
    }

    /**
     * Validates a domain name
     * @param {string} domain - The domain name to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkDomain(
        domain: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(domain, this.patterns.domain, mode);
    }

    /**
     * Validates a semantic version string
     * @param {string} version - The version string to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkSemver(
        version: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(version, this.patterns.semver, mode);
    }

    /**
     * Validates a phone number
     * @param {string} phone - The phone number to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkPhoneNumber(
        phone: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(phone, this.patterns.phone, mode);
    }

    /**
     * Validates a credit card number
     * @param {string} card - The credit card number to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkCreditCard(
        card: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(card, this.patterns.creditCard, mode);
    }

    /**
     * Validates a Social Security Number (SSN)
     * @param {string} ssn - The SSN to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkSSN(
        ssn: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(ssn, this.patterns.ssn, mode);
    }

    /**
     * Validates an ISBN (International Standard Book Number)
     * @param {string} isbn - The ISBN to validate
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkISBN(
        isbn: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(isbn, this.patterns.isbn, mode);
    }

    /**
     * Validates a time string
     * @param {string} time - The time string to validate (HH:MM format)
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkTime(
        time: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(time, this.patterns.time, mode);
    }

    /**
     * Validates a password against different security levels
     * @param {string} password - The password to validate
     * @param {ValidationLevel} [level='medium'] - The security level to validate against
     * @param {ValidatorMode} [mode] - Optional validation mode
     * @returns {ValidationResult | boolean} Validation result
     */
    public checkPassword(
        password: string,
        level: ValidationLevel = 'medium',
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(
            password,
            this.complexPatterns.password[level],
            mode,
        );
    }
    /**
     * Validates a postal code for a specific country.
     *
     * @param {string} code - The postal code to validate.
     * @param {CountryCode} country - The two-letter country code to validate against.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     * @example
     * // Valid postal code for US
     * validator.checkPostalCode('90210', 'US'); returns true
     *
     * // Verbose mode example
     * validator.checkPostalCode('90210', 'US', 'verbose');
     * returns { isValid: true, message: 'Postal code is valid for the US' }
     */
    public checkPostalCode(
        code: string,
        country: CountryCode,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(
            code,
            this.complexPatterns.postalCode[country],
            mode,
        );
    }

    /**
     * Validates a cryptocurrency address.
     *
     * @param {string} address - The cryptocurrency address to validate.
     * @param {CryptoType} type - The type of cryptocurrency.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkCryptoAddress(
        address: string,
        type: CryptoType,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        return this.validate(address, this.complexPatterns.crypto[type], mode);
    }

    /**
     * Validates a pair of geographical coordinates (latitude, longitude).
     *
     * @param {string} lat - Latitude to validate.
     * @param {string} lng - Longitude to validate.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkCoordinates(
        lat: string,
        lng: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const latValid = this.validate(
            lat,
            this.complexPatterns.coordinates.latitude,
            mode,
        );
        const lngValid = this.validate(
            lng,
            this.complexPatterns.coordinates.longitude,
            mode,
        );
        return mode === 'verbose'
            ? {
                  isValid:
                      typeof latValid === 'boolean'
                          ? latValid &amp;&amp; typeof lngValid === 'boolean'
                              ? lngValid
                              : false
                          : false,
                  message: 'Both latitude and longitude must be valid',
              }
            : typeof latValid === 'boolean'
            ? latValid &amp;&amp; typeof lngValid === 'boolean'
                ? lngValid
                : false
            : false;
    }

    /**
     * Custom validation based on a provided regular expression pattern.
     *
     * @param {string} value - The value to validate.
     * @param {RegExp} pattern - The regular expression pattern to match.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public customValidation = (
        value: string,
        pattern: RegExp,
        mode?: ValidatorMode,
    ): ValidationResult | boolean => this.validate(value, pattern, mode);

    /**
     * Validates a date string against a given format.
     *
     * @param {string} date - The date string to validate.
     * @param {string} [format='DD/MM/YYYY'] - The format to validate against.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkDate(
        date: string,
        format: string = 'DD/MM/YYYY',
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const patterns: { [key: string]: RegExp } = {
            'DD/MM/YYYY': /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[0-2])\/\d{4}$/,
            'MM/DD/YYYY': /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/,
            'YYYY-MM-DD': /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/,
            'YYYY/MM/DD': /^\d{4}\/(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])$/,
        };
        return this.validate(
            date,
            patterns[format] || patterns['DD/MM/YYYY'],
            mode,
        );
    }

    /**
     * Validates a UUID string.
     *
     * @param {string} uuid - The UUID string to validate.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkUUID(
        uuid: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const uuidPattern =
            /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return this.validate(uuid, uuidPattern, mode);
    }

    /**
     * Validates a strong password based on given options.
     *
     * @param {string} password - The password to validate.
     * @param {Object} options - Validation options.
     * @param {number} [options.minLength=8] - Minimum length of the password.
     * @param {boolean} [options.requireUppercase=true] - Whether uppercase letters are required.
     * @param {boolean} [options.requireNumbers=true] - Whether numbers are required.
     * @param {boolean} [options.requireSpecialChars=true] - Whether special characters are required.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkStrongPassword(
        password: string,
        options: {
            minLength?: number;
            requireUppercase?: boolean;
            requireNumbers?: boolean;
            requireSpecialChars?: boolean;
        } = {},
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const opts = {
            minLength: 8,
            requireUppercase: true,
            requireNumbers: true,
            requireSpecialChars: true,
            ...options,
        };

        let pattern = '^';
        pattern += `.{${opts.minLength},}`;
        if (opts.requireUppercase) pattern += '(?=.*[A-Z])';
        if (opts.requireNumbers) pattern += '(?=.*\\d)';
        if (opts.requireSpecialChars) pattern += '(?=.*[!@#$%^&amp;*])';

        return this.validate(password, new RegExp(pattern), mode);
    }

    /**
     * Validates a slug (a URL-friendly string).
     *
     * @param {string} slug - The slug string to validate.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkSlug(
        slug: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const slugPattern = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
        return this.validate(slug, slugPattern, mode);
    }

    /**
     * Validates a base64-encoded string.
     *
     * @param {string} base64 - The base64 string to validate.
     * @param {ValidatorMode} [mode] - Optional validation mode. If 'verbose', detailed result will be returned.
     * @returns {ValidationResult | boolean} Validation result, or boolean if no mode is provided.
     */
    public checkBase64(
        base64: string,
        mode?: ValidatorMode,
    ): ValidationResult | boolean {
        const base64Pattern =
            /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
        return this.validate(base64, base64Pattern, mode);
    }
}

export default RegExpValidator;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>


</body>
</html>
